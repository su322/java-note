import java.util.Scanner;

public class Study {
	public static void main(String[] args) {
		//项目 模块 包 类
		//'\t'制表符的作用：把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。
		//System.out.println("name"+'\t'+"age");
		//System.out.println("tom"+'\t'+"23");
		//二进制开头0b，八进制开头0，十六进制开头0x
		//范围：byte8bit short2*8 int4*8 long8*8
		//需要加后缀的：
		//long l = 999L;
		//float f = 10.1F; 
		//小驼峰方法、变量名 大驼峰类名
		/*Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		System.out.println(a+b);*/
		//如果有小数参与运算，结果有可能不精确
		/*
		个位%10
		十位/10%10
		百位/100%10...
		*/
		//隐式转换 自动类型提升 小的提升为大的或者 比int小的byte short char自己做运算直接提升到int
		//ASCII a97 A65 048
		//b = a++ 先用后加
		//b = ++a 先加后用
		//s += 1等于s = (short)(s + 1) 这类二元运算符隐藏了一个强制类型转换
		//^ 逻辑异或 不同为true，相同为false & | ...这些不是短路 会输出按位运算结果
		//短路逻辑运算符 && || 短路就是左边的能确定最终运行结果右边的就不用运行了 输出布尔值
		//三元运算符 a?b:c
		//正数原反补相同 负数反码符号位不变其他位取反 补码在反码基础上加一
		//<< 向左移动，低位补0 左移一次就是乘2
		//>> 向右移动 高位补0或1 右移一次就是除以2
		//>>> 无符号右移 高位补0
		//switch default可以省略，不建议 不写break会把下面的全部执行直到break
		//回文数 不用乘除的除法 力扣
		//Random r = new Random();
		//int num = r.nextInt(100) + 1;范围是0+1~99+1 左闭右开
		//交换数组数据 打乱数组数据
		//方法运行时使用的内存，进入方法栈中执行，new出来创建的，都存储在堆内存
		//psvm sout快速
		//方法的重载必须参数有变化 不管是数量还是类型 不建议顺序不同的重载
		//int[] arr = new int[]{1, 2, 3, 4, 5}; new int[]可以省略，但还是new出来的。int[]是引用数据类型
		//ctrl+alt+M 抽取方法
		//如果自己没有写构造方法，虚拟机会自己加一个空参方法，如果只写了有参构造方法，空参方法就没有了，建议任何时候都手动写上空参和带全部参数的构造方法。
		//标准的JavaBean类，就是比较标准的类的样子，ptg插件可以根据成员变量一键生成那样的方法。
		//alt+insert是官方自动生成的快捷键
		//java内存分配主要是方法区、栈内存、堆内存，不记得了的话可以重新看一下这个视频
		//类在被首次主动使用时，其字节码需要经过加载阶段进入方法区
		//还有基本数据类型和引用数据类型的区别，数据值存的位置不同
		//this的本质是代表方法调用者的地址值，是由虚拟机赋值的
		//字符串用next()
		//键盘录入的两套体系不能混用：nextInt nextLine！
		//先用nextInt再用nextLine会导致下面的nextLine接收不到，因为它直接把nextInt没有接受的回车接受了
		//字符串在创建之后是不会发生改变的。
		//字符串的创建方式还有
		//char[] = {'a', 'b', 'c', 'd'};
		//String s = new String(chs);
		//还有
		//byte[] bytes = {1, 2, 3, 4};
		//String s = new String(bytes);
		//String是引用数据类型，作比较比的是地址值
		//字符串对象的boolean equals方法 完全一样才是true，boolean equalsIgnoreCase方法 忽略大小写的比较
		//next()的是new出来的，只要想比较字符串的内容就必须要用String里面的方法
		//ctrl+alt+v 自动生成左边的部分，比如下面这句的左边的char c = 部分
		//str.charAt(i) i是字符串的索引，返回字符串索引处的字符
		//fori快速
		//子串 字符串对象.substring(a, b) 左闭右开 或者是substring(a) 就是a后面的
		//字符串对象.replace(target, relacement)替换
		//StringBuilder是java已经写好的类，可以看做是一种容器，java在底层对他做了一些特殊处理，打印对象不是地址而是属性值
		//用法可以去看jdk api文档 append reverse toString length
		//链式编程：当我们在调用一个方法的时候，不需要用变量接受他的结果，可以继续调用其他方法
		//使用StringBuilder的场景有高效拼接和反转等 String对于大量拼接速度很慢
		//StringJoiner(间隔符号, 开始符号, 结束符号) 或者 (间隔符号) add length toString 可以高效拼接
		//字符串相关类的底层原理可以看视频
		//直接赋值的字符串放在堆内存中一个叫字符串常量池（串池）的地方，地址在串池中，而new出来的字符串不在串池中，在堆内存中
		//字符串拼接在JDK8之前和之后是不一样的，jdk8之前每次都会先创建StringBuilder对象，然后调用append方法拼接，再用toString方法转换成String类型，而toString方法的底层是直接new了一个字符串对象
		//jdk8之后系统会预估字符串拼接后的总大小，把要拼接的内容都放到数组中，此时也是产生了一个新的字符串
		//如果很多字符串变量拼接，不要直接+，由于java字符串的不可变性，每次操作都会创建一个新的String对象来存储结果，从而产生中间字符串对象浪费时间和性能。推荐用StringBuilder，使用可变的字符数组，可以在不创建新对象的情况下进行多次拼接，只有在调用toString()时才会创建一个最终的String对象
		//"abc"和"a"+"b"+"c" 如果在+的时候没有变量参与，在编译的时候就会拼接上，运行的时候就会复用串池里的
		//StringBuilder里的概念： 容量 Capacity()：最大可容纳的 长度 length()：实际有的 StringBuilder默认容量16，当超出范围时会扩容：老容量*2+2=34，如果超出了34就以实际容量为准
		//数组长度固定，集合长度可变
		//ArrayList<String> list = new ArrayList<> jdk7后可以省略 <E>泛型：限定集合中存储数据的类型 不能存基本数据类型
		//打印对象不是地址值，而是集合中存储的数据内容，在展示的时候会拿[]把所有的数据进行包裹
		//增删改查
		//add remove索引或者元素 set根据索引 get根据索引 size初始值是0
		//基本数据类型对应的包装类就是首字母小写变大写，除了char是Character，int是Integer
		//ctrl+p可以看构造函数，可以对着写
		//在Java中，case "1" -> 这种语法是Java12引入的增强版switch表达式的一部分（也称为"箭头语法"）。它与传统的case "1":有以下区别：箭头->表示：不需要使用break语句（自动防止case穿透），右侧只能跟一个表达式、代码块或throw语句，更简洁的语法风格
		//ctrl+alt+L 快速整理代码格式 会和qq快捷键冲突
		//静态变量是随着类的加载而加载的，优先于对象出现的，jdk7之前在方法区，之后放在堆内存中的静态区，不属于对象，属于类，推荐类名调用
		//静态方法多用在测试类和工具类中，javabean类中很少会用，推荐类名调用
		//测试类：用来检查其他类是否书写正确，带有main方法的类，程序入口
		//工具类：不是用来描述一类事物，而是帮我们做一些事情的类。需要私有化构造方法，为了不被外界创建对象，成员方法需要定义为静态的，方便调用，一般命名为xxxUtil
		//静态方法只能访问静态变量和静态方法，非静态方法都可以访问，静态方法中没有this关键字。
		//重新认识main方法：public被JVM调用，访问权限足够大；static被JVM调用，不用创建对象，直接类名访问，因为main方法是静态的，所以测试类中其他方法也需要是静态的；void被JVM调用，不需要给JVM返回值；main一个通用的名称，虽然不是关键字，但是被JVM识别；String[] args以前用于接收键盘录入数据的，现在没用
		//public class Student extends Person 继承 子类（派生类） 父类（基类或超类）
		//java只支持单继承，不支持多继承，但支持多层继承。java中所有类都直接或间接继承于Object类。
		//成员变量不管是私有的还是非私有的子类都可以继承，都拷贝过来了，只不过私有的不能直接用，
		//在new一个继承了父类的对象时，堆内存里新建的的对象会分为两个区域，一个放父类的变量，一个放自己的
		//父类的在虚方法表里成员方法的子类能继承，否则不能继承。Java为每个类维护虚方法表，包含可覆盖的方法（非private、非static、非final），子类通过复制-替换-扩展的方式继承父类的虚方法表
		//继承中成员变量访问特点：就近原则：先在局部位置找，本类成员位置找，父类成员位置找，逐级往上
		//出现了重名的成员变量就看怎么调 比如 name this.name super.name 分别从不同的位置往上找
		//如果在成员方法里没有写调用者默认是this调用。
		//@Override重写注解，放在重写后的方法上，校验子类重写时语法是否正确，建议都加，代码安全、优雅。
		//建议重写的方法尽量和父类保持一致，虽然有一些规则，名称、形参列表必须与父类中的一致，访问权限子类必须大于父类，返回值类型子类必须小于等于父类。只有被添加到虚方法表中的方法才能被重写，上面也提到了。
		//构造方法不能被子类继承，因为方法名字肯定不一样。但是，子类中所有的构造方法默认先访问父类中的无参构造，再执行自己（下面也说了）。因为子类在初始化时有可能会用到父类中的数据，所以，子类初始化之前一定要调用父类构造方法先完成父类数据空间的初始化。
		//子类构造方法的第一行语句默认都是super()，不写也存在，且必须在第一行。如果想调用父类有参构造，必须手动写super进行调用。
		//
	}
}