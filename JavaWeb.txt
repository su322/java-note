Ajax：异步的JavaScript和XML，Axios对原生Ajax进行了封装，简化书写，快速开发
Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。特点是占用内存少，并发能力强
Maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置
依赖具有传递性，也可以<exclusions><exclusion>主动断开不需要的依赖 <scope>可以设置依赖的作用范围compile test provided runtime
Maven的生命周期是为了对所有的maven项目构建过程进行抽象和统一，生命周期有clean default site，在同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行
HTTP请求数据格式：请求行、请求头、请求体
GET请求参数在请求行中，没有请求体，GET请求大小是有限制的；POST请求参数在请求体中，POST请求大小是没有限制的
HTTP响应格式：响应行、响应头、响应体
各种参数...各种注解 统一相应结果...

Tomcat：开源免费的轻量级web服务器，支持Servlet/JSP少量JavaEE规范，也被称为web容器、servlet容器，于springboot的起步依赖中内嵌
三层架构：Cotroller，控制层，接收请求，响应数据；Service，业务逻辑层，逻辑处理；dao，数据访问层（Data Access Object）（持久层）负责数据访问操作，包括数据的增删改查
面向接口编程不错
软件设计原则：高内聚低耦合
控制反转：Inverse Of Control，简称IOC，对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转
依赖注入：Dependency Injection，简称DI，容器为应用程序提供运行时，所依赖的资源，称之为依赖注入
Bean对象：IOC容器中创建、管理的对象，称之为bean
步骤：实现类用@Component（可以用下面的衍生注解替换）交给IOC容器管理，要用到的其他类的对象用@AutoWired进行依赖注入
@Component的衍生注解：@Controller 标注在控制器类上（RestController已经包括了Controller），@Service 标注在业务类上，@Repository 标注在数据访问类上（由于与mybatis整合，用得少）
前面声明的注解要想生效，还需要被组件扫描注解@ComponentScan扫描，它虽然没有显式配置，但是实际上已经包含在了启动类声明注解中，默认扫描的范围是启动类所在包及其子包
如果同时写了多个@Service，会不知道自动装配哪一个Bean，就会报错，也可以在其中一个上面加上@Primary，就使这个Bean生效，或者可以在@Autoawired下面加上@Qualifier("想要使用的Bean，没指定名字默认是类名，首字母小写")，或者可以在即将创建对象的那行语句的上面加上@Resource("同样的")，不用写@Service
@Resource与@AutoWired的区别：前者是JDK提供的注解，后者是spring框架提供的注解；前者如果写name属性是是按照名称注入，不写是按照类型注入，后者默认是按照类型注入

关系型数据库（RDB）：建立在关系模型基础上，由多张相互连接的二维表组成的数据库
SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。通常被分为四大类：DDL DML DQL DCL 语法太多...
参考：
select job,count(*) from tb_emp where entrydate<='2015-01-01' group by job having count(*) >= 2;
where和having区别：1、执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤 2、判断条件不同：where不能对聚合函数进行判断，而having可以
分组之后，查询的字段一般是聚合函数和分组字段，查询其他字段无意义
asc升序 desc降序
order by a, b desc; 先按照a排，a相同，再按照b排
limit 0,5 从索引0开始，展示五条12345
limit 5,5 从索引5开始，展示五条678910
起始索引=（查询页码-1）*每页显示记录数
分页查询是数据库的方言，不同的数据库有不同的实现
echarts
if(条件表达式，true取值，false取值)
case 表达式 when 值1 then 结果2 when 值2 then 结果2 ... else ... end
物理外键（foreign key）缺点：影响增删改的效率（需要检查外键关系），仅用于单节点数据库，不适用于分布式、集群场景，容易引发数据库的死锁问题，消耗性能
逻辑外键：在业务层逻辑中，解决外键关联
一对多（多的一方添加外键关联一的主键）、一对一、多对多（中间表）
笛卡尔积：两个集合的所有组合情况
多表查询中，需要消除无效的笛卡尔积
分类：	连接查询： 
			内连接：相当于查询A、B交集部分数据
			隐式 select tb_emp.name,tb_dept.name from tb_emp,tb_dept where tb_emp.dept_id = tb_dept.id;
			显式 select tb_emp.name,tb_dept.name from tb_emp inner join tb_dept on tb_emp.dept_id = tb_dept.id;
			外连接：
				左外连接：查询左表所有数据（包括交集）left join on
				右外连接：查询右表所有数据（包括交集）right join on
		子查询：
			标量子查询 where dept_id = (select id from tb_dept where name = '教研部');
			列子查询 where dept_id in (2,3);
			行子查询 where (entrydate,job)=('2007-01-01',2);
			表子查询 select e.*, d.name from (select * from tb_emp where entrydate > '2006-01-01') e, tb_dept d where e.dept_id = d.id;
上面写的只是部分举例

事务：一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。
四大特性：
		原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败
		一致性：事务完成时，必须使所有的数据都保持一致状态
		隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
		持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的
start transaction;
...
commit;
rollback;

索引是帮助数据库高效获取数据的数据结构，缺点是会占用存储空间，大大提高了查询效率，同时却也降低了insert、update、delete的效率
默认B+树（多路平衡搜索树）结构组织的索引
主键字段，在建表时，会自动创建主键索引。添加唯一约束时，数据库实际上会添加唯一索引

MyBatis是一款优秀的持久层框架，用于简化JDBC的开发
实体类变量用包装类创建，因为基本类型的默认值会造成干扰，而包装类为null不会干扰

JDBC(Java DataBase Connectivity)：使用java语言操作关系型数据库的一套API 硬编码，繁琐，资源浪费，性能降低
数据库连接池是个容器，负责分配、管理数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个，释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 最好的有阿里巴巴的druid 和springboot默认的hikari
Lombok是一个实用的Java类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString
等方法，并可以自动化生成日志变量，简化java开发、提高效率@Data @NoArgsContructor @AllArgsContructor 我感觉是看起来简洁

预编译SQL 性能更高 更安全（防止SQL注入）
使用#{...}占位符 执行SQL时，会将#{...}替换为?，生成预编译SQL，会自动设置参数值。使用时机：参数传递，都使用#{...}
使用${...}占位符 拼接SQL，直接将参数拼接在SQL语句中，存在SQL注入问题。使用时机：如果对表名、列表进行动态设置时使用

数据库数据到实体类的映射封装：起别名 手动结果映射 开启驼峰命名 （数据库的下划线格式映射成成员变量的小驼峰格式）
mybatis.configuration.map-underscore-to-camel-case=true

concat 字符串拼接函数 concat('%', '#{name}', '%') 可以写在sql语句中

XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）。
XML映射文件的namespace属性为Mapper接口全限定名一致。
XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致（全类名）。

随着用户的输入或外部条件的变化而变化的SQL语句，我们称为动态SQL。
1. <if>
用于判断条件是否成立，如果条件为true，则拼接SQL。
形式:<if test="name != null">..</if>
2. <where>
where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR
3. <set>
动态地在行首插入SET关键字，并会删掉额外的逗号。（用在update语句中）

<foreach>
SQL语句：delete from emp where id in (1,2,3);
接口方法：
#批量删除
public void deleteBylds(List<Integer> ids);
XML映射文件：
<delete id="deleteBylds">
	delete from emp where id in
	<foreach collection="ids" item="id" separatqr="," open="(" close=")">
		#{id}
	</foreach>
</delete>

sql片段
<sql>：定义可重用的SQL片段。
<include>：通过属性refid，指定包含的sql片段。

开发规范-Restful
REST(Representational StateTransfer)：表述性状态转换，它是一种软件架构风格
URL定位资源，HTTP动词描述操作
REST是风格，是约定方式，约定不是规定，可以打破。
描述模块的功能通常使用复数，也就是加s的格式来描述，表示此类资源，而非单个资源。如：users、emps、books...

@slf4j 就可以用log.info了

impl：implementation 实现类集合，不是接口implements

/**回车 快速注释

条件分页查询：条件查询：动态SQL-XML映射文件 分页查询：PageHelper分页插件

uuid：通用唯一识别码 用于构造唯一的文件名
在SpringBoot中，文件上传，默认单个文件允许最大大小为1M。如果需要上传大文件，可以进行如下配置：
#配置单个文件最大上传大小
spring.servlet.multipart.max-file-size=10MB
#配置单个请求最大上传大小（一次请求可以上传多个文件）
spring.servlet.multipart.max-request-size=100MB

#启用mybatis日志输出
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

@Value注解通常用于外部配置的属性注入，具体用法为：@Value("${配置文件中的key)")

alt+鼠标左键拖动 可以拖从同一个位置开始的多行代码

SpringBoot提供了多种属性配置方式
1.application.properties

server.port=8080
server.address=127.0.0.1

推荐后面的
2.application.yml

server:
	port:8080
	address:127.0.0.1

3.application.yaml

server:
	port:8080
	address:127.0.0.1
	
yml
基本语法：
大小写敏感
数值前边必须有空格，作为分隔符
使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）
缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
#表示注释，从这个字符一直到行尾，都会被解析器忽略

@ConfigurationProperties与 @Value
相同点
都是用来注入外部配置的属性的。
不同点
@Value注解只能一个一个的进行外部属性的注入
@ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中。

json格式要用实体类接收

会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。
会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。

Cookie
优点：HTTP协议中支持的技术
缺点：
移动端APP无法使用Cookie
不安全，用户可以自己禁用cookie
Cookie不能跨域

跨域区分三个维度：协议、IP/域名、端口

Session
优点：存储在服务端，安全
缺点：
服务器集群环境下无法直接使用Session
Cookie的缺点

令牌技术
优点：
支持PC端、移动端
解决集群环境下的认证问题
减轻服务器端存储压力
缺点：需要自己实现

JWT
简介
全称:JSON Web Token (https://jwt.io/)
定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。
组成:
第一部分：Header(头)，记录令牌类型、签名算法等。例如：{"alg":"HS256","type":"JWT"}
第二部分：Payload(有效载荷)，携带一些自定义信息、默认信息等。例如：{"id":"1","username":"Tom"}
第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload,并加入指定秘钥，通过指定签名算法计算而来。

Base64:是一种基于64个可打印字符（A-Za-Z0-9+/）来表示二进制数据的编码方式。

场景：登录认证。
1.登录成功后，生成令牌
2.后续每个请求，都要携带JWT令牌，系统在每次请求处理之前，先校验令牌，通过后，再处理

JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。
如果JWT令牌解析校验时报错，则说明JWT令牌被篡改或失效了，令牌非法。

思路
令牌生成：登录成功后，生成JWT令牌，并返回给前端。
令牌校验：在请求到达服务端后，对令牌进行统一拦截、校验。

概念：Filter 过滤器，是JavaWeb 三大组件(Servlet、Filter、Listener)之一。
过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。
过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。

1.定义Filter：定义一个类，实现Filter接口，并重写其所有方法。
2.配置Filter：Filter类上加@WebFilter注解，配置拦截资源的路径。引导类上加@ServletComponentScan开启Servlet组件支持。

执行流程：请求-->放行前逻辑-->放行-->资源-->放行后逻辑
一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链。执行顺序可以想一下
顺序：注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序。

概念：Interceptor 拦截器 是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，用来动态拦截控制器方法的执行。
作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。

1.定义拦截器，实现HandlerInterceptor接口，并重写其所有方法。
2.注册拦截器 拦截路径的写法和过滤器有区别

Filter与 Interceptor 两种用一种就可以 都有的话顺序是前者在前，后者在后
接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现Handlerlnterceptor接口。
拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。

步骤
获取请求url。
判断请求url中是否包含login，如果包含，说明是登录操作，放行。
获取请求头中的令牌(token)。
判断令牌是否存在，如果不存在，返回错误结果（未登录）。
解析token，如果解析失败，返回错误结果（未登录）。
放行。

出现异常，该如何处理？
方案一：在Controller的方法中进行try...catch处理 代码臃触，不推荐
方案二：全局异常处理器 简单、优雅，推荐

全局异常处理器
@RestControllerAdvice = @RestController + @ResponseBody
@ExceptionHandler

示例：
@RestControllerAdvice
public class GlobalExceptionHandler{
	@ExceptionHandler(Exception.class)//捕获所有异常
	public Result ex(Exception ex) {
		ex.printStackTrace();
		return Result.error("对不起，操作失败,请联系管理员");
	}
}

