由于JVM需要实时解释虚拟机指令，不做任何优化不如直接运行机器码的C、C++等语言，所以JVM提供了即时编译（Just-In-Time JIT）进行性能的优化，最终能达到接近C、C++的运行性能，甚至在特定场景下超越

双亲委派机制有什么用？
1.保证类加载的安全性
通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。
2.避免重复加载
双亲委派机制可以避免同一个类被多次加载。

双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再由顶向下进行加载。

Java使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GCRoot)和普通对象，对象与对象之间存在引用关系。
下图中A到B再到C和D，形成了一个引用链，可达性分析算法指的是如果从某个到GCROOt对象是可达的，对象就不可被回收。

哪些对象被称之为GCRoot对象呢?
线程Thread对象，引用线程栈帧中的方法参数、局部变量等。
系统类加载器加载的java.lang.Class对象。
监视器对象，用来保存同步锁synchronized关键字持有的对象。
本地方法调用时使用的全局对象。

1960年JohnMcCarthy发布了第一个GC算法：标记-清除算法。
1963年MarvinL.Minsky发布了复制算法。
本质上后续所有的垃圾回收算法，都是在上述两种算法的基础上优化而来。

垃圾回收算法-标记清除算法
优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。
缺点：
1.碎片化问题
由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。
2.分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。

垃圾回收算法-复制算法
复制算法的核心思想是：
1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。
2.在垃圾回收GC阶段，将From中存活对象复制到To空间。
3.将两块空间的From和To名字互换。
复制算法的优缺点
呑吐量高
复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动
不会发生碎片化
复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。
内存使用效率低
每次只能让一半的内存空间来为创建对象使用

垃圾回收算法-标记整理算法
标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。
核心思想分为两个阶段：
1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GCRoot开始通过引l用链遍历出所有存活对象。
2.整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。
标记整理算法的优缺点
内存使用效率高
整个堆内存都可以使用，不会像复制算法只能使用半个堆内存
不会发生碎片化
在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间
整理阶段的效率不高
整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过TwO-Finger、表格算法、ImmixGc等高效的整理算法优化此阶段的性能

垃圾回收算法-分代垃圾回收算法
现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法(Generational GC)。
分代垃圾回收将整个内存区域划分为年轻代和老年代：
分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。
随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。
MinorGC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。

接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生MinorGC。
此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0。
注意：每次MinorGC中都会为对象记录他的年龄，初始值为O，每次GC完加1。

如果MinorGC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。
当老年代中空间不足，无法放入新的对象时，先尝试minorgc如果还是不足，就会触发FullGC，FullGC会对整个堆进行垃圾回收。
如果FullGC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出OutOfMemory异常

程序中大部分对象都是朝生夕死，在年轻代创建并且回收，只有少量对象会长期存活进入老年代。分代垃圾回收的优点有：
1、可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。
2、新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法效率高、不会产生内存碎片，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。
3、分代的设计中允许只回收新生代(minorgc)，如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW(StopTheWorld)由垃圾回收引起的停顿时间就会减少。

