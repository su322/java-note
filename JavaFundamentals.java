import java.util.Scanner;

public class JavaFundamentals {
	public static void main(String[] args) {
		//项目 模块 包 类
		//'\t'制表符的作用：把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。
		//System.out.println("name"+'\t'+"age");
		//System.out.println("tom"+'\t'+"23");
		//二进制开头0b，八进制开头0，十六进制开头0x
		//范围：byte8bit short2*8 int4*8 long8*8
		//需要加后缀的：
		//long l = 999L;
		//float f = 10.1F; 
		//小驼峰方法、变量名 大驼峰类名
		/*Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		System.out.println(a+b);*/
		//如果有小数参与运算，结果有可能不精确
		/*
		个位%10
		十位/10%10
		百位/100%10...
		*/
		//隐式转换 自动类型提升 小的提升为大的或者 比int小的byte short char自己做运算直接提升到int
		//ASCII a97 A65 048
		//b = a++ 先用后加
		//b = ++a 先加后用
		//s += 1等于s = (short)(s + 1) 这类二元运算符隐藏了一个强制类型转换
		//^ 逻辑异或 不同为true，相同为false & | ...这些不是短路 会输出按位运算结果
		//短路逻辑运算符 && || 短路就是左边的能确定最终运行结果右边的就不用运行了 输出布尔值
		//三元运算符 a?b:c
		//正数原反补相同 负数反码符号位不变其他位取反 补码在反码基础上加一
		//<< 向左移动，低位补0 左移一次就是乘2
		//>> 向右移动 高位补0或1 右移一次就是除以2
		//>>> 无符号右移 高位补0
		//switch default可以省略，不建议 不写break会把下面的全部执行直到break
		//回文数 不用乘除的除法 力扣
		//Random r = new Random();
		//int num = r.nextInt(100) + 1;范围是0+1~99+1 左闭右开
		//交换数组数据 打乱数组数据
		//方法运行时使用的内存，进入方法栈中执行，new出来创建的，都存储在堆内存
		//psvm sout快速
		//方法的重载必须参数有变化 不管是数量还是类型 不建议顺序不同的重载
		//int[] arr = new int[]{1, 2, 3, 4, 5}; new int[]可以省略，但还是new出来的。int[]是引用数据类型
		//ctrl+alt+M 抽取方法
		//如果自己没有写构造方法，虚拟机会自己加一个空参方法，如果只写了有参构造方法，空参方法就没有了，建议任何时候都手动写上空参和带全部参数的构造方法。
		//标准的JavaBean类，就是比较标准的类的样子，ptg插件可以根据成员变量一键生成那样的方法。
		//alt+insert是官方自动生成的快捷键
		//java内存分配主要是方法区、栈内存、堆内存，不记得了的话可以重新看一下这个视频
		//类在被首次主动使用时，其字节码需要经过加载阶段进入方法区
		//还有基本数据类型和引用数据类型的区别，数据值存的位置不同
		//this的本质是代表方法调用者的地址值，是由虚拟机赋值的
		//字符串用next()
		//键盘录入的两套体系不能混用：nextInt nextLine！
		//可以统一用nextLine
		//先用nextInt再用nextLine会导致下面的nextLine接收不到，因为它直接把nextInt没有接受的回车接受了
		//字符串在创建之后是不会发生改变的。
		//字符串的创建方式还有
		//char[] = {'a', 'b', 'c', 'd'};
		//String s = new String(chs);
		//还有
		//byte[] bytes = {1, 2, 3, 4};
		//String s = new String(bytes);
		//String是引用数据类型，作比较比的是地址值
		//字符串对象的boolean equals方法 完全一样才是true，boolean equalsIgnoreCase方法 忽略大小写的比较
		//next()的是new出来的，只要想比较字符串的内容就必须要用String里面的方法
		//ctrl+alt+v 自动生成左边的部分，比如下面这句的左边的char c = 部分
		//str.charAt(i) i是字符串的索引，返回字符串索引处的字符
		//fori快速
		//子串 字符串对象.substring(a, b) 左闭右开 或者是substring(a) 就是a后面的
		//字符串对象.replace(target, relacement)替换
		//StringBuilder是java已经写好的类，可以看做是一种容器，java在底层对他做了一些特殊处理，打印对象不是地址而是属性值
		//用法可以去看jdk api文档 append reverse toString length
		//链式编程：当我们在调用一个方法的时候，不需要用变量接受他的结果，可以继续调用其他方法
		//使用StringBuilder的场景有高效拼接和反转等 String对于大量拼接速度很慢
		//StringJoiner(间隔符号, 开始符号, 结束符号) 或者 (间隔符号) add length toString 可以高效拼接
		//字符串相关类的底层原理可以看视频
		//直接赋值的字符串放在堆内存中一个叫字符串常量池（串池）的地方，地址在串池中，而new出来的字符串不在串池中，在堆内存中
		//字符串拼接在JDK8之前和之后是不一样的，jdk8之前每次都会先创建StringBuilder对象，然后调用append方法拼接，再用toString方法转换成String类型，而toString方法的底层是直接new了一个字符串对象
		//jdk8之后系统会预估字符串拼接后的总大小，把要拼接的内容都放到数组中，此时也是产生了一个新的字符串
		//如果很多字符串变量拼接，不要直接+，由于java字符串的不可变性，每次操作都会创建一个新的String对象来存储结果，从而产生中间字符串对象浪费时间和性能。推荐用StringBuilder，使用可变的字符数组，可以在不创建新对象的情况下进行多次拼接，只有在调用toString()时才会创建一个最终的String对象
		//"abc"和"a"+"b"+"c" 如果在+的时候没有变量参与，在编译的时候就会拼接上，运行的时候就会复用串池里的
		//StringBuilder里的概念： 容量 Capacity()：最大可容纳的 长度 length()：实际有的 StringBuilder默认容量16，当超出范围时会扩容：老容量*2+2=34，如果超出了34就以实际容量为准
		//数组长度固定，集合长度可变
		//ArrayList<String> list = new ArrayList<> jdk7后可以省略 <E>泛型：限定集合中存储数据的类型 不能存基本数据类型
		//打印对象不是地址值，而是集合中存储的数据内容，在展示的时候会拿[]把所有的数据进行包裹
		//增删改查
		//add remove索引或者元素 set根据索引 get根据索引 size初始值是0
		//ctrl+p可以看构造函数，可以对着写
		//在Java中，case "1" -> 这种语法是Java12引入的增强版switch表达式的一部分（也称为"箭头语法"）。它与传统的case "1":有以下区别：箭头->表示：不需要使用break语句（自动防止case穿透），右侧只能跟一个表达式、代码块或throw语句，更简洁的语法风格
		//ctrl+alt+L 快速整理代码格式 会和qq快捷键冲突
		//静态变量是随着类的加载而加载的，优先于对象出现的，jdk7之前在方法区，之后放在堆内存中的静态区，不属于对象，属于类，推荐类名调用
		//静态方法多用在测试类和工具类中，javabean类中很少会用，推荐类名调用
		//测试类：用来检查其他类是否书写正确，带有main方法的类，程序入口
		//工具类：不是用来描述一类事物，而是帮我们做一些事情的类。需要私有化构造方法，为了不被外界创建对象，成员方法需要定义为静态的，方便调用，一般命名为xxxUtil
		//静态方法只能访问静态变量和静态方法，非静态方法都可以访问，静态方法中没有this关键字。
		//重新认识main方法：public被JVM调用，访问权限足够大；static被JVM调用，不用创建对象，直接类名访问，因为main方法是静态的，所以测试类中其他方法也需要是静态的；void被JVM调用，不需要给JVM返回值；main一个通用的名称，虽然不是关键字，但是被JVM识别；String[] args以前用于接收键盘录入数据的，现在没用
		//public class Student extends Person 继承 子类（派生类） 父类（基类或超类）
		//java只支持单继承，不支持多继承，但支持多层继承。java中所有类都直接或间接继承于Object类。
		//成员变量不管是私有的还是非私有的子类都可以继承，都拷贝过来了，只不过私有的不能直接用，
		//在new一个继承了父类的对象时，堆内存里新建的的对象会分为两个区域，一个放父类的变量，一个放自己的
		//父类的在虚方法表里成员方法的子类能继承，否则不能继承。Java为每个类维护虚方法表，包含可覆盖的方法（非private、非static、非final），子类通过复制-替换-扩展的方式继承父类的虚方法表
		//继承中成员变量访问特点：就近原则：先在局部位置找，本类成员位置找，父类成员位置找，逐级往上
		//出现了重名的成员变量就看怎么调 比如 name this.name super.name 分别从不同的位置往上找
		//如果在成员方法里没有写调用者默认是this调用。
		//@Override重写注解，放在重写后的方法上，校验子类重写时语法是否正确，建议都加，代码安全、优雅。
		//建议重写的方法尽量和父类保持一致，虽然有一些规则，名称、形参列表必须与父类中的一致，访问权限子类必须大于父类，返回值类型子类必须小于等于父类。只有被添加到虚方法表中的方法才能被重写，上面也提到了。
		//构造方法不能被子类继承，因为方法名字肯定不一样。但是，子类中所有的构造方法默认先访问父类中的无参构造，再执行自己（下面也说了）。因为子类在初始化时有可能会用到父类中的数据，所以，子类初始化之前一定要调用父类构造方法先完成父类数据空间的初始化。
		//子类构造方法的第一行语句默认都是super()，不写也存在，且必须在第一行。
		//如果想调用父类有参构造，必须手动写super进行调用，比如
		//public Student(String name, int age) {
		//	super(name, age);
		//}
		//如果写
		//public Student(){
		//	this(null, 0, "xx");
		//}
		//空参构造这样写表示调用本类其他构造方法（这个是调用了全参构造方法，并且进行了默认赋值），这样虚拟机就不会再添加super()
		//总结一下就是：this(...)访问本类构造方法，super(...)访问父类构造方法
		//子类的全参构造可以这样写，父类 + 子类
		//public Manager(String id, String name, double salary, double bonus) {
		//	super(id, name, salary);
		//	this.bonus = bonus;
		//}
		
		//多态：同类型的对象，表现出的不同形态
		//写法：Fu f = new Zi();
		//前提：有继承关系，有父类引用指向子类对象，有方法重写
		//好处：使用父类型作为参数，可以接受所有子类对象，体现多态的扩展性与便利
		//比如
		//public static void register(Person p){
		//	p.show();
		//}
		//可以传Student Teacher等子类，就不用每个都专门写一个方法
		//但是也有弊端：不能使用子类的特有功能。如果一定要使用，需要进行类型转换
		//引用数据类型的类型转换有自动类型转换、强制类型转换
		//这里只说第二个，强制类型转换可以转换成真正的子类类型，从而调用子类特有功能，转换类型与真实对象类型不一样会报错，转换的时候可以用instanceof关键字进行判断
		//比如
		//if(a instanceof Dog){
		//	Dog d = (Dog)a;
		//	d.lookhome();
		//}else if(){...
		//jdk14之后有新特性，可以写的更简便，先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d，如果不是，则不强转，结果直接是false
		//if(a instanceof Dog d){
		//	d.lookhome();
		//}else if(){...
		//另外，多态调用成员变量的特点：编译看左边，运行也看左边
		//javac编译代码的时候，会看左边的父类有没有这个变量，如果有，编译成功，如果没有编译失败
		//java运行代码的时候，实际获取的就是左边父类中成员变量的值
		//多态调用成员方法的特点：编译看左边，运行看右边
		//第一个一样
		//java运行代码的时候，实际上运行的是子类中的方法
		//这些要去看内存图解比较好理解
		//包就是文件夹，用来管理各种不同功能的java类
		//包名规则：公司域名反写+包的作用，需要全部英文小写，见名知意
		//使用其他类时，除非已经import，否则需要使用全类名，但是有同名的也要用全类名
		//java.lang包不用导
		//final修饰方法表明该方法是最终方法，不能被重写 public (static) final ...
		//修饰类表明该类是最终类，不能被继承
		//修饰变量叫做常量，只能被赋值一次 命名规范：全部大写，多个单词用下划线隔开
		//final修饰的变量是基本类型，变量存储的数据值不能发生改变；是引用类型，那么变量存储的地址值不能发生改变，对象内部的属性值可以改变
		//ctrl+shift+u 转大写
		//权限修饰符 一般只用private public
		
		//修饰符		同一个类中		同一个包中其他类		不同包下的子类		不同包下的无关类
		//private		1				0					0				0
		//空着不写		1				1					0				0
		//protected		1				1					1				0
		//public		1				1					1				1
		
		//如果是本类用的封装了用于重复利用的辅助方法，这个方法一般也私有
		//局部代码块{} 有局部作用域 提前结束变量的生命周期
		//构造代码块 写在成员变量下面位置的{} 可以把多个构造方法中重复的代码抽取出来 先执行构造代码块再执行构造方法	//上面两个都渐渐不用了，一个是现在存储空间大了，一个是不灵活（都会执行代码块里的，如果确实要这样用，可以写成员方法调用）
		//静态代码块 static{} 随着类的加载而加载，并且自动触发，只执行一次 在类加载的时候做一些数据初始化并且数据只想用一次的时候使用
		//抽象方法 public abstract 返回值类型...
		//抽象方法所在的类叫抽象类 public abstract class... 可以有构造方法，作用是在创建子类对象时，给属性进行赋值的
		//抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
		//抽象类的子类要么重写抽象类中的所有抽象方法，要么是抽象类
		
		//接口：就是一种规则 public interface 接口名{}
		//接口不能实例化 接口和类之间是实现关系，通过implements关键字表示 public class 类名 implements 接口名{} 可以多继承接口
		//接口的子类（实现类） 要么重写接口中的所有抽象方法 要么是抽象类
		//接口中成员的特点：成员变量只能是常量，默认修饰符：public static final。没有构造方法。成员方法只能是抽象方法，默认修饰符：public abstract
		//不同接口中有同名方法，实现类中只需要重写一次（可能需要理解一下，同名的就代表同一个功能了）
		//接口和接口的关系：继承关系，可以单、多继承 extends 如果实现类实现了最下面的子接口，那么所有的都要全部重写
		//jdk7以前：接口中只能定义抽象方法，jdk8：接口中可以定义有方法体的方法，默认方法public default...不强制被重写，如果被重写，重写的时候去掉default关键字，public可以省略，default不能省略，如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。静态方法public static... 只能通过接口名调用，不能通过实现类名或者对象名调用，public可以省略
		//jdk9：接口中可以定义私有方法，普通的私有方法为接口内默认方法服务的，静态的私有方法给静态方法服务的
		//当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以使用适配器设计模式
		//书写步骤：编写中间类xxxAdapter，实现对应的接口，对接口中的抽象方法进行空实现，让真正的实现类继承中间类，并重写需要用的方法，为了避免其他类创建适配器类的对象，中间的适配器类用abstract进行修饰
		//内部类表示的事物是外部类的一部分，内部类单独出现没有任何意义。内部类可以直接访问外部类的成员，包括私有，外部类要访问内部类的成员，必须创建对象。
		//jdk16开始在成员内部类里面可以定义静态变量
		
		//这个地方细节太复杂了，但是获取成员内部类对象的两种方式：
		//内部类权限如果是public，可以用Outer.Inner inner = new Outer().new Inner();直接创建Inner对象
		//内部类权限如果是private，上面的不能用，要么改成public，要么可以在外部类写一个方法
		//public Inner getInstance(){
		//	return new Inner();
		//}对外提供内部类对象
		//测试类可以写以Object多态的方式接受 Object inner = new Outer().getInstance()，但是感觉一般。
		
		//成员内部类获取外部类变量
		//如果有外部类、内部类、内部类方法同名的变量，直接写变量名是就近原则，或者写this.就是内部的，写Outer.this.就是外部的
		//内部类对象里面有一个隐藏的外部类对象的this用于记录外部类对象的地址值 Outer.this 这个就要用内存分析工具去看了
		//创建静态内部类对象的格式：Outer.Inner inner = new Outer.Inner(); 
		//调用静态方法： Outer.Inner.method(); 调用非静态方法：先创建对象，用对象调用
		//局部内部类：将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量
		//外界无法直接使用局部内部类，需要在方法内部创建对象并使用
		//该类可以直接访问外部类的成员，也可以访问方法内的局部变量
		//匿名内部类本质上就是隐藏了名字的内部类
		//new 类名或者接口名(){重写方法} 有点抽象 实际上这是匿名内部类的对象 匿名内部类是大括号里的，也就是没有名字的内部类
		//编译之后还是有名字的，生成的字节码文件可以看出
		//如果类只用一次，就可以用匿名内部类简化代码
		//method(new Inter(){重写方法}) 可以这样调用method(传一个对象) 其实是多态
		//他也可以自己创建的时候直接调用内部的方法
		//他妈的也可以写在成员位置，是没有名字的成员内部类 有点太多了
		
		//Math abs absExact(jdk15) ceil floor round max pow random[0,1) sqrt cbrt 
		//判断质数 一个整数的两个因子中一个因子必定小于等于平方根，另一个因子必定大于等于平方根
		//计算机中的时间原点 1970年1月1日 C语言的生日 我国有几小时差别
		
		//System exit currentTimeMillis arraycopy 如果数据原数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错 在拷贝的时候需要考虑数组的长度，如果超出范围也会报错 如果数据原数组与目的数组都是引用类型，那么子类类型可以赋值给父类类型
		
		//Runtime 要用getRuntime获取对象才行 exit availableProcessors maxMemory totalMemory freeMemory exec
		
		//Object toString（和直接打印对象效果相同，如果打印一个对象想看到属性值就重写toString方法就可以了，因为底层用了这个方法） equals（基本数据类型不能用，然后Object和String类的equals不一样，比较对象时会重写，比较对象属性值是否相同） 
		//clone 默认浅克隆（浅拷贝） 重写Object中的clone方法，让javabean类实现Cloneable接口（如果一个接口里面没有抽象方法，表示当前的接口是一个标记型接口），创建原对象并调用clone就可以了
		//浅拷贝 不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来
		//深拷贝 基本数据类型拷贝过来，String在串池里管理所以会复用，还是同样的地址，但是引用数据类型就是新的地址
		//可以利用第三方工具类gson
		
		//Objects equals（先做非空判断） 判断对象 isNull nonNull
		
		//BigInteger 静态方法BigInteger.valueOf(100) 构造方法new BigInteger("100")... add subtract multtply divide divideAndRemainder equals pow max/min intValue LongValue
		//如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取（在-16~+16之间做了优化，会节约内存），如果超出long的范围，可以用构造方法获取。对象一旦创建，BigInteger内部记录的值不能发生改变，只要进行计算都会产生一个新的BigInteger对象。
		
		//BigDecimal 表示较大的小数和解决小数运算精度失真问题 如果要表示的数字不大，没有超出double的取值范围，建议使用静态方法，否则使用构造方法
		
		//正则表达式 regex 字符串.matches("条件") 字符类 预定义字符类 数量词
		//Pattern p = Pattern.compile("条件");
		//Matcher m = p.matcher(外面传的str);
		//boolean b = m.find();//一次
		//String s1 = m.group;
		//sout(s1);
		//正则的规则有点太多了，自己查吧，我觉得ai也很擅长
		//贪婪 非贪婪 分组：捕获分组 非捕获分组...
		
		//格林威治时间GMT 原子钟UTC
		//Date date = new Date(不写或指定毫秒值); setTime(毫秒值) getTime()
		//new SimpleDateFormat(pattern) parse format
		//Calender 不能直接创建对象 getInstance getTimeInMillis setTimeInMillis get set add
		//jdk8新增时间相关类 ZoneIds Instant ZonedDateTime DateTimeFormatter LocalDate LocalTime LocalDateTime Duration Period ChronoUnit
		
		//基本数据类型对应的包装类就是首字母小写变大写，除了char是Character，int是Integer
		//构造方法和静态方法获取Integer的区别：
		//静态方法valueOf：在实际开发中，-128~127之间的数据，用的比较多，如果每次都是new对象，太浪费内存了，所以提前把这个范围之内的每一个数据都创建好对象，如果要用到了不会创建新的，而是返回已经创建的；构造方法因为是new出来的，java中每一次new都是创建一个新的对象，地址不一样。
		//jdk5提出自动装箱：把基本数据类型自动变成对应的包装类，自动拆箱：把包装类自动变成对象的基本数据类型
		//8种包装类中，除了Character都有对应的parseXxx的方法，进行类型转换
		//sb.insert(0, data) 可以倒着插入 append不可以
		//LocalDate里的isLeapYear可以直接判断闰年
		
		//基本查找 二分查找 分块查找 插值查找 斐波那契查找 树表查找 哈希查找
		//
		}
	}
}